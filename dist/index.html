<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>PDF Viewer Example</title>
        <style>
            [ng-cloak] {
                display: none !important;
            }
        </style>
        <link rel="stylesheet" href="pdf_viewer.css" />
        <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.css" />
        <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>

        <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.2.1/angular-material.min.css" />

        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular-animate.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular-aria.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular-messages.min.js"></script>

        <script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.2.1/angular-material.min.js"></script>

        <script src="./kcd-recompile.js"></script>

        <script defer="defer" src="pdf.js"></script>
        <script defer="defer" src="pdf_viewer.js"></script>
        <style>
            #rt-presentation-container {
                height: 100% !important;
                overflow: hidden !important;
            }

            #rt-presentation-container .swiper-wrapper {
                margin: 0 auto !important;
            }

            #rt-presentation-container .pdfViewer.removePageBorders .page {
                margin: 0;
            }

            #rt-presentation-container .canvasWrapper {
                height: 100%;
                align-items: center;
                display: flex;
            }

            #rt-presentation-container .page {
                margin: 0;
                border: none;
                background-color: transparent;
            }

            #rt-presentation-container.viewerContainer {
                position: relative;
                width: 100%;
                height: 100%;
            }

            #pdfviewer-coverflow-wrapper-container.viewerContainer {
                position: relative;
                width: 100%;
                height: 100%;
            }

            .viewerContainer {
                overflow: visible !important;
            }

            .page {
                position: relative !important;
                border: none !important;
                height: 100%;
                width: 100%;
                justify-content: center;
                align-items: center;
                display: flex;
            }

            .canvasWrapper,
            .textLayer,
            .annotationLayer > * {
                z-index: 1 !important;
            }

            .annotationLayer section {
                position: absolute;
                text-align: initial;
            }

            .swiper-wrapper {
                align-items: center;
            }
            /* Effect styles */

            .rt-swiper-cube .page.swiper-slide.swiper-slide-active::after,
            .rt-swiper-cards .page.swiper-slide.swiper-slide-active::after {
                pointer-events: auto;
                opacity: 1;
                transition: opacity 0.3s ease-in-out;
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                box-shadow: 0 0 1px rgb(0 0 0 / 12%), 0 1px 1px rgb(0 0 0 / 4%), 0 2px 2px rgb(0 0 0 / 4%), 0 4px 4px rgb(0 0 0 / 4%), 0 8px 8px rgb(0 0 0 / 4%);
            }

            .rt-swiper-cube .page.swiper-slide:not(.swiper-slide-active) .annotationLayer,
            .rt-swiper-cube .page.swiper-slide:not(.swiper-slide-active)::after,
            .rt-swiper-cards .page.swiper-slide:not(.swiper-slide-active) .annotationLayer,
            .rt-swiper-cards .page.swiper-slide:not(.swiper-slide-active)::after {
                pointer-events: none;
                opacity: 0;
            }

            .page.swiper-slide:not(.swiper-slide-active) {
                overflow: hidden;
            }

            .page.swiper-slide {
                position: relative !important;
                border: none !important;
                height: 100%;
                width: 100%;
                justify-content: center;
                align-items: center;
                display: flex;
            }

            /* SLides */
            .rt-swiper-slide .viewerContainer,
            .rt-swiper-fade .viewerContainer {
                flex: 1;

                width: 100% !important;
                height: 100% !important;
            }

            .rt-swiper-slide .page.swiper-slide,
            .rt-swiper-fade .page.swiper-slide {
                overflow: hidden;
            }

            .rt-slides-view-container.rt-swiper-slide .pdfViewer .page.swiper-slide,
            .rt-slides-view-container.rt-swiper-fade .pdfViewer .page.swiper-slide {
                background-color: transparent;
            }

            .rt-swiper-slide .page.swiper-slide > .annotationLayer,
            .rt-swiper-slide .page.swiper-slide > .textLayer,
            .rt-swiper-fade .page.swiper-slide > .annotationLayer,
            .rt-swiper-fade .page.swiper-slide > .textLayer {
                position: absolute;
                left: unset;
                top: unset;
                right: unset;
                bottom: unset;
            }

            /* Annotations */
            .annotationLayer .linkAnnotation > a:hover {
                opacity: 0.35 !important;
                background: linear-gradient(45deg, #428cca 10%, #a4dfff 90%);
                margin: -2% 0 0 -2%;
                padding: 2%;
                box-sizing: content-box;
            }
            /* Text layer */
            .textLayer > span {
                color: transparent;
                position: absolute;
                white-space: pre;
                cursor: text;
                -webkit-transform-origin: 0% 0%;
                transform-origin: 0% 0%;
            }
        </style>
    </head>

    <body ng-cloak ng-app="demo">
        <div ng-controller="Controller as vm" kcd-recompile="vm.recompile" use-boolean flex layout="column" layout-fill>
            <div flex layout="column">
                <md-input-container style="margin: 0;">
                    <input ng-model="vm.pdfUrl" ng-change="vm.initSwiperPDF()" ng-model-options="{debounce: 500 }" />
                </md-input-container>

                <div layout="row">
                    <md-button class="md-primary md-mini md-fab" no-ink ng-click="vm.zoomIn()">
                        +
                    </md-button>
                    <md-button class="md-primary md-mini md-fab" no-ink ng-click="vm.zoomOut()">
                        -
                    </md-button>

                    <md-switch ng-model="vm.renderAsScroll" ng-change="vm.updateView()">
                        Render as Scroll
                    </md-switch>

                    <md-switch ng-model="vm.enabledSVG" ng-change="vm.updateView()">
                        Enable SVG
                    </md-switch>

                    <div flex layout="row" layout-align="end center">
                        <div ng-if="!vm.renderAsScroll" ng-repeat="effect in vm.effects">
                            <md-button md-no-ink class="md-primary" ng-class="{'md-raised':effect.active}" ng-click="vm.selectEffect(effect)">
                                {{effect.type}}
                            </md-button>
                        </div>
                    </div>
                </div>

                <div ng-if="!vm.renderAsScroll" flex layout="column" layout-align="center center">
                    <div class="rt-swiper-{{vm.activeEffect.type}}" flex style="position: relative; height: 100%;">
                        <div id="rt-presentation-container" class="swiper viewerContainer">
                            <div class="pdfViewer swiper-wrapper"></div>
                        </div>
                        <div class="swiper-button-prev"></div>
                        <div class="swiper-button-next"></div>
                    </div>
                </div>

                <div ng-if="vm.renderAsScroll" style="position: relative; width: 100%; height: 100%;">
                    <div id="rt-presentation-container" style="position: absolute; left: 0; right: 0;">
                        <div class="pdfViewer"></div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            function makeid(length) {
                var result = '';
                var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var charactersLength = characters.length;
                for (var i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * charactersLength));
                }
                return result;
            }

            angular.module('demo', ['ngMaterial', 'ngMessages', 'kcd.directives']).controller('Controller', function ($timeout) {
                var vm = this;
                vm.selectEffect = selectEffect;
                vm.initSwiperPDF = initSwiperPDF;
                vm.effects = [
                    {id: makeid(8), active: true, type: 'slide'},
                    {id: makeid(8), active: false, type: 'fade'},
                    {id: makeid(8), active: false, type: 'cube'},
                    {id: makeid(8), active: false, type: 'coverflow'},
                    {id: makeid(8), active: false, type: 'flip'},
                    {id: makeid(8), active: false, type: 'creative'},
                    {id: makeid(8), active: false, type: 'cards'}
                ];

                function getOptions() {
                    var relaytoPagesView = {};
                    if (vm.enabledSVG) {
                        for (var i = 0; i < vm.view.PDFViewer.pagesCount; i++) {
                            relaytoPagesView[i + 1] = {
                                embed: {pdfSvg: true}
                            };
                        }
                    }

                    return {relaytoPagesView};
                }

                function selectEffect(active) {
                    vm.activeEffect = active;
                    vm.effects.map((effect) => {
                        effect.active = effect.id === active.id;
                        return effect;
                    });

                    vm.updateView();
                }

                function initSwiperPDF(options = {}) {
                    Object.assign(options, {effect: vm.activeEffect.type});

                    $timeout(() => {
                        vm.view = new SwiperPDF(options);
                        console.log('vm.view', vm.view);
                    });
                }

                function updateSwiper() {
                    $timeout(() => {
                        vm.view.swiper.el.querySelectorAll('.page').forEach((page) => {
                            if (vm.view.effect === 'slide' || vm.view.effect === 'fade') {
                                var parentElementDims = page.parentElement.getBoundingClientRect();
                                page.style.width = parentElementDims.width + 'px';
                                page.style.height = parentElementDims.height + 'px';
                            }
                        });
                    });
                }

                vm.zoomIn = () => {
                    vm.view.zoomScale++;
                    vm.view.PDFViewer.zoomIn(vm.view.zoomScale);

                    updateSwiper();
                };
                vm.zoomOut = () => {
                    if (vm.view.zoomScale > 0) {
                        vm.view.PDFViewer.zoomOut(vm.view.zoomScale);
                        vm.view.zoomScale--;
                    }

                    updateSwiper();
                };

                vm.updateView = function () {
                    initSwiperPDF(getOptions());

                    vm.recompile = true;
                };

                vm.$onInit = function () {
                    vm.renderAsScroll = false;

                    vm.pdfUrl = 'test.pdf';

                    vm.recompile = false;
                    vm.activeEffect = angular.copy(vm.effects).filter((e) => e.active)[0];

                    initSwiperPDF();
                };

                class SwiperPDF {
                    PDFViewer = window.rtPDFViewer;

                    containerId = null;

                    options = {};
                    effect = null;
                    swiper = null;
                    zoomScale = 0;

                    constructor(options) {
                        this.options = options;

                        this.effect = options.effect;
                        this.containerId = 'rt-presentation-container';
                        this.initPDFViewer();
                    }

                    render = () => {
                        this.PDFViewer.eventBus.on('resize', (val) => {
                            console.log('val', val);

                            updateSwiper();
                        });

                        if (!vm.renderAsScroll) {
                            this.PDFViewer.eventBus.on('pagesinit', (val) => {
                                $timeout(() => {
                                    var container = document.querySelector('.swiper');
                                    document.querySelectorAll('.swiper .page').forEach(function (pageDiv, idx) {
                                        pageDiv.classList.add('swiper-slide', 'swiper-slide-layout-align');

                                        if (idx === 0) {
                                            container.style.width = pageDiv.style.width;
                                            container.style.height = pageDiv.style.height;
                                        }
                                    });
                                    this.initSwiper();
                                });
                            });
                        }
                    };

                    initPDFViewer() {
                        this.PDFViewer.initialize(
                            Object.assign(
                                {
                                    removePageBorders: true,
                                    scrollable: true,
                                    containerId: this.containerId,
                                    currentScaleValue: 'page-fit',
                                    cMapUrl: '/pdf-js/cmaps/',
                                    cMapPacked: true
                                },
                                this.options
                            )
                        );

                        var self = this;

                        this.PDFViewer.open(vm.pdfUrl).then(this.render);
                    }

                    initSwiper() {
                        let self = this;
                        const swiper = document.querySelector('.swiper');
                        const pages = document.querySelectorAll('.page');

                        pages.forEach((page) => {
                            page.classList.add('swiper-slide', 'swiper-slide-layout-align');
                            swiper.style.width = page.style.width;
                            swiper.style.height = page.style.height;
                        });

                        const conf = {
                            noSwipingSelector: '.textLayer > span, .swiper-no-swiping',
                            effect: self.effect,
                            grabCursor: true,
                            navigation: {
                                nextEl: `.swiper-button-next`,
                                prevEl: `.swiper-button-prev`
                            },
                            keyboard: {
                                enabled: true,
                                onlyInViewport: true
                            },
                            on: {
                                afterInit: function () {},
                                beforeTransitionStart: (swiper) => {
                                    var activeIndex = swiper.activeIndex;
                                    var slideBefore = activeIndex - 3 < 0 ? 0 : activeIndex - 3;
                                    var slideAfter = activeIndex + 3 > swiper.slides.length ? swiper.slides.length - 1 : activeIndex + 3;
                                    rtPDFViewer.updateSlide(slideBefore, slideAfter);
                                    rtPDFViewer.page = activeIndex + 1;
                                },
                                slideChangeTransitionEnd: (swiper) => {},
                                activeIndexChange: (swiper) => {
                                    var pageDiv = swiper.slides[swiper.activeIndex];
                                    var canvasWrapperDiv = pageDiv.querySelector('.canvasWrapper');

                                    if (canvasWrapperDiv && canvasWrapperDiv.firstChild) {
                                        ['.annotationLayer', '.textLayer'].map(function (className) {
                                            var div = pageDiv.querySelector(className);
                                            if (div) {
                                                switch (true) {
                                                    case div.className === 'annotationLayer' && (self.effect === 'slide' || self.effect === 'fade'):
                                                    case div.className === 'textLayer':
                                                        div.style.width = canvasWrapperDiv.firstChild.style.width;
                                                        div.style.height = canvasWrapperDiv.firstChild.style.height;
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }

                                            pageDiv.querySelectorAll('.annotationLayer section').forEach(function (section) {
                                                if (section.style.transform && section.style.transform.indexOf('translateZ') === -1) {
                                                    section.style.transform += ' translateZ(1px)';
                                                }
                                            });
                                        });
                                    }
                                }
                            }
                        };

                        if (self.effect === 'creative') {
                            conf.creativeEffect = {
                                prev: {
                                    shadow: true,
                                    origin: 'left center',
                                    translate: ['-5%', 0, -200],
                                    rotate: [0, 100, 0]
                                },
                                next: {
                                    origin: 'right center',
                                    translate: ['5%', 0, -200],
                                    rotate: [0, -100, 0]
                                }
                            };
                        }

                        console.log('conf', conf);

                        self.swiper = new Swiper('.swiper', conf);
                    }
                }
            });
        </script>
    </body>
</html>
